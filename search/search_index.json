{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Formal ORM","text":"<p>This ORM focuses on simplifying data manipulation.</p> <p>This is achieved by:</p> <ul> <li>using immutable objects</li> <li>each aggregate owning the objects it references</li> <li>using monads to fetch aggregates (from the Innmind ecosystem)</li> <li>using the specification pattern to match aggregates</li> </ul> <p>This allows:</p> <ul> <li>simpler app design (as it can be pure)</li> <li>memory efficiency (the ORM doesn't keep objects in memory)</li> <li>long living processes (since there is no memory leaks)</li> <li>to work asynchronously</li> </ul> Sneak peak <pre><code>use Formal\\ORM\\{\n    Manager,\n    Sort,\n};\nuse Formal\\AccessLayer\\Connection\\PDO;\nuse Innmind\\Url\\Url;\n\n$manager = Manager::sql(\n    PDO::of(Url::of('mysql://user:pwd@host:3306/database?charset=utf8mb4')),\n);\n$_ = $manager\n    -&gt;repository(YourAggregate::class)\n    -&gt;all()\n    -&gt;sort('someProperty', Sort::asc)\n    -&gt;drop(150)\n    -&gt;take(50)\n    -&gt;foreach(static fn($aggregate) =&gt; doStuff($aggregate));\n</code></pre> <p>If you've worked with C# Entity Framework you should find a few similarities.</p>"},{"location":"benchmark/","title":"Benchmark","text":"<p>A small benchmark as a reference point for the performance of this ORM consists in generating and persisting 100K users in a single transaction and then loading them.</p> <pre><code>time php benchmark/fill_storage.php\nphp benchmark/fill_storage.php  222.24s user 5.20s system 60% cpu 6:18.40 total\ntime php benchmark/load.php\nMemory: 40.00 Mo\nphp benchmark/load.php  11.06s user 0.08s system 97% cpu 11.388 total\n</code></pre> <p>This means the ORM can load 1 aggregate in 0.1 millisecond.</p> <p>This was run on a MacbookPro 16\" with a M1 Max with the mariadb running inside Docker.</p> <p>If all the aggregates were to be stored in memory it would take around 2Go of RAM and 15 seconds to complete.</p>"},{"location":"enums/","title":"Enums","text":"<p>Formal natively support enums as a property and inside collections (1).</p> <ol> <li>Via <code>Set</code>s.</li> </ol> <p>This means you don't need to create custom types for each enum in your project, it just works.</p> Info <p>Formal uses the <code>case</code> name as the value persisted in the storage. Even when you use backed enums.</p> <p>In order to search aggregates having an enum case inside a collection you can use this specification:</p> Find oneFind amongst many <pre><code>use Formal\\ORM\\Specification\\Child\\Enum;\n\nEnum::any(\n    'collectionPropertyName',\n    YourEnum::someCase,\n)\n</code></pre> <p>This will return the aggregate if this case is present in the collection.</p> <pre><code>use Formal\\ORM\\Specification\\Child\\Enum;\n\nEnum::in(\n    'collectionPropertyName',\n    YourEnum::someCase,\n    YourEnum::someOtherCase,\n)\n</code></pre> <p>This will return the aggregate if one of the cases is present in the collection.</p>"},{"location":"issues/","title":"Known issues","text":""},{"location":"issues/#mapping","title":"Mapping","text":""},{"location":"issues/#aggregate-name-collision","title":"Aggregate name collision","text":"<p>By default the ORM translate an Aggregate class to a simple name in the adapter. For example the class <code>App\\Domain\\User</code> is translated to <code>user</code>. This allows to simplify reading the storage folders/tables/indexes.</p> <p>For small projects this is fine. But for larger projects names collision may arise.</p> <p>For example you may have the aggregates <code>App\\Domain\\Shipping\\Product</code> and <code>App\\Domain\\Billing\\Product</code> that would result in the same <code>product</code> name in the storage.</p> <p>You can fix it like this:</p> <pre><code>use Formal\\ORM\\{\n    Manager,\n    Definition\\Aggregates,\n    Definition\\Types,\n};\n\n$orm = Manager::of(\n    /* your storage adapter (1) */,\n    Aggregates::of(\n        Types::default(),\n    )-&gt;mapName(static fn(string $class) {\n        \\App\\Domain\\Shipping\\Product::class =&gt; 'shippingProduct',\n        \\App\\Domain\\Billing\\Product::class =&gt; 'billingProduct',\n    }),\n);\n</code></pre> <ol> <li>see Adapters</li> </ol> <p>This also allows to fix the default casing of names. For example the class <code>App\\Domain\\DocumentTemplate</code> result in the name <code>documenttemplate</code>. Which is not very readable.</p> <p>This behaviour won't be change for the time being to not break existing projects. But you can gradually fix this via the <code>mapName</code> method.</p>"},{"location":"issues/#floating-points","title":"Floating points","text":"<p>By default Formal doesn't support <code>float</code> as a property type but it allows you to use it if you need to.</p> <p>Storing <code>float</code>s is a tricky business because of the decimal part precision. Not every system will represent the same value the same way and you may end up with implicit convertions. Meaning you may not retrieve the exact value you put in.</p> <p>Formal tries to be as explicit as it can be. Supporting by default a type with implicit behaviours is a sure way to bugs.</p> <p>That being said you can still create a custom type and normalize that type to a <code>float</code> at the storage level. This way you have to determine how to represent the value in your storage and can control the precision.</p> Info <p>If you're not familiar with the <code>float</code> problems, you can read this, rather long, article from Oracle on how floating points are represented by a system and errors associated.</p> <p>You can also watch this talk (in french).</p>"},{"location":"issues/#elasticsearch","title":"Elasticsearch","text":""},{"location":"issues/#searching-with-endswith","title":"Searching with <code>endsWith</code>","text":"<p>When searching aggregates via a specification with <code>Sign::endsWith</code> you may not always see all the results.</p> <p>Internally this search uses the <code>wildcard</code> query with the value starting with <code>*</code>. As described in the documentation this SHOULD NOT be used as it's an expensive query.</p> <p>If you really need to do this kind of search you could add an extra property on your aggregate with the string being in reversed order from the original one. You can then do a search on this property with <code>Sign::startsWith</code> and reversing the string used as argument.</p> <p>Bear in mind that <code>startsWith</code> also uses the <code>wildcard</code> query and may be slower that you'd want or even not return the results you'd expect.</p>"},{"location":"limitations/","title":"Limitations","text":"<p>Due to the current design of entities not having ids it is not possible to build a diff of collections of entities. This means that as soon as a collection is modified the whole collection is persisted to the storage.</p> <p>For small sets of entities this is fine but can become quite time consuming if you store a lot of data inside a given collection.</p>"},{"location":"limitations/#elasticsearch","title":"Elasticsearch","text":"<p>This adapter has 2 major limitations:</p> <ul> <li>it does not support transactions</li> <li>it can't list more than 10k aggregates</li> </ul> <p>Elasticsearch have no concept of transactions. The adapter implementation do not try to emulate a transaction mechanism as it would be too complex. This means that has soon you make an operation on a repository the change is directly applied to the underlying index.</p> <p>The Elasticsearch api doesn't allow a pagination above 10k documents. This is a hardcoded behaviour on their part, this is a design choice as to not interpret an index as a database. This means that if you have more than 10k aggregates you won't be able to list them all.</p> <p>These limitations mean that you can't swap another adapter by this one without behaviours changes in your app.</p>"},{"location":"pagination/","title":"Pagination","text":"<p>Formal is optimized to be memory efficient so you can do this without running out of memory:</p> <pre><code>$orm\n    -&gt;repository(User::class)\n    -&gt;all()\n    -&gt;foreach(static fn(User $user) =&gt; businessLogic($user));\n</code></pre> <p>But if you're building a HTTP API you don't want to return all the aggregates from your storage in the response. The go-to approach is to use pagination and return a fixed amount of aggregates.</p> <p>This is very simple with Formal:</p> Page 0Page 1Page 2Page 3etc... <pre><code>use Formal\\ORM\\Sort;\n\n$usersArray = $orm\n    -&gt;repository(User::class)\n    -&gt;all()\n    -&gt;sort('name', Sort::asc)\n    -&gt;take(100)\n    -&gt;sequence()\n    -&gt;toList();\n</code></pre> <pre><code>use Formal\\ORM\\Sort;\n\n$usersArray = $orm\n    -&gt;repository(User::class)\n    -&gt;all()\n    -&gt;sort('name', Sort::asc)\n    -&gt;drop(100)\n    -&gt;take(100)\n    -&gt;sequence()\n    -&gt;toList();\n</code></pre> <pre><code>use Formal\\ORM\\Sort;\n\n$usersArray = $orm\n    -&gt;repository(User::class)\n    -&gt;all()\n    -&gt;sort('name', Sort::asc)\n    -&gt;drop(200)\n    -&gt;take(100)\n    -&gt;sequence()\n    -&gt;toList();\n</code></pre> <pre><code>use Formal\\ORM\\Sort;\n\n$usersArray = $orm\n    -&gt;repository(User::class)\n    -&gt;all()\n    -&gt;sort('name', Sort::asc)\n    -&gt;drop(300)\n    -&gt;take(100)\n    -&gt;sequence()\n    -&gt;toList();\n</code></pre> <pre><code>use Formal\\ORM\\Sort;\n\n$page = 4;\n$pageSize = 100;\n$usersArray = $orm\n    -&gt;repository(User::class)\n    -&gt;all()\n    -&gt;sort('name', Sort::asc)\n    -&gt;drop($page * $pageSize)\n    -&gt;take($pageSize)\n    -&gt;sequence()\n    -&gt;toList();\n</code></pre> <p>This also works with <code>-&gt;repository()-&gt;matching()</code>.</p> <p>The sort allows the pagination to be stable (the same query will return the same results).</p> Warning <p>The order of <code>drop</code> and <code>take</code> is important.</p> <p>The repository is treated as a virtual <code>Sequence</code> for design consistency. If you take <code>100</code> aggregates and then drop <code>1_000</code> then the result is necessarily empty.</p> <p>This allows these 2 examples to be equivalent:</p> Storage optimizedIn memory <pre><code>use Formal\\ORM\\Sort;\n\n$page = 1;\n$pageSize = 100;\n$usersArray = $orm\n    -&gt;repository(User::class)\n    -&gt;all()\n    -&gt;sort('name', Sort::asc)\n    -&gt;drop($page * $pageSize)\n    -&gt;take($pageSize)\n    -&gt;sequence()\n    -&gt;toList();\n</code></pre> <pre><code>use Formal\\ORM\\Sort;\n\n$page = 1;\n$pageSize = 100;\n$usersArray = $orm\n    -&gt;repository(User::class)\n    -&gt;all()\n    -&gt;sort('name', Sort::asc)\n    -&gt;sequence()\n    -&gt;drop($page * $pageSize)\n    -&gt;take($pageSize)\n    -&gt;toList();\n</code></pre>"},{"location":"philosophy/","title":"Philosophy","text":"<p>This ORM goal is to allow users to store data in long living processes (like a daemon or a queue consumer) and asynchronous apps.</p> <p>The long living processes use case implies that the ORM must be memory efficient to avoid memory leaks that would crash your app. The asynchronous use case implies that the ORM must be agnostic of the context in which it's run, this means that no code needs to be changed for this to work.</p> <p>This goal is achieved by:</p> <ul> <li>using Monads</li> <li>using Trees instead of a Graph</li> <li>using immutable Aggregates</li> </ul> <p>By being strict in its design this ORM also prevents you from using it in a way that it doesn't support. It's intended to push you to find an alternative tool instead of letting you shoot yourself in the foot.</p>"},{"location":"philosophy/#monads","title":"Monads","text":"<p>To be memory efficient we need to represent a collection of data that can be streamed. This is why this ORM uses the <code>Sequence</code> monad when fetching aggregates.</p> <p>For design consistency this ORM uses the <code>Maybe</code> monad when fetching an aggregate by id. Instead of returning the aggregate or throwing an exception when no value is found. This also allows the retrieval to be deferred. Meaning that if you never unwrap the monad there will be no call made to the storage.</p> <p>The <code>Maybe</code> monad is also used to wrap optional entities in your aggregates. Meaning that these entities are not fetched unless you need it to. The eventual fetch from the storage is transparent in your code. But once loaded it stays in memory, as long as your aggregate is in memory.</p> <p>The <code>Set</code> monad is used to represent collections of entities and works the same way as <code>Maybe</code>. No data fetched by default but once it is loaded it stays in memory.</p>"},{"location":"philosophy/#trees-not-a-graph","title":"Trees, not a Graph","text":"<p>Traditionnally ORMs use the same data representation as the SQL database they try to abstract. And since SQL is about relations you end up with your objects pointing to each other resulting in a big Graph of objects. To avoid loading your whole database in memory these ORMs use proxy objects (and thus use inheritance) to load relationships only when used.</p> <p>The problem with this approach is that you may still reach a memory exhaustion because once an object is loaded it stays in memory even if you no longer need it.</p> <p>This ORM partly move away from the SQL model by using Trees. A tree is a tree of objects meaning a root object is the only owner of the objects it references. This allows to safely free memory when you no longer use this root object as no other object has ownership of the relations.</p> <p>In this package a Tree is called an Aggregate and objects it references Entities. This terminology comes from the Domain Driven Design concept.</p> <p>This is because each Aggregate is independent and encapsulate ownership of data that we can stream them via the <code>Sequence</code> monad.</p>"},{"location":"philosophy/#immutability","title":"Immutability","text":"<p>To make sure an Aggregate is the only owner of the data it's supposed to encapsulate it MUST be immutable. This means that if you want to update its data you must create a copy with the data modified.</p> <p>Thanks to immutability it guarantees that there is only one owner of any object. The ORM is then able to compute a diff to only update the data that changed since when you fetched the aggregate.</p> <p>The ORM doesn't need to create proxies for your objects. This means you can declare all your classes <code>final</code> so no one can change their behaviour.</p> <p>Immutability also reduces the risk to persist partial modifications. Any modification of an aggregate returns a copy. This means you have to explicitly call the repository to apply a change.</p> Example Mutable objectImmutable object <pre><code>final class User\n{\n    public function __construct(\n        private string $name,\n    ) {}\n\n    public function rename(string $name): self\n    {\n        $this-&gt;name = $name;\n\n        return $this;\n    }\n}\n</code></pre> <pre><code>$user1 = new User('foo');\n$user2 = $user1-&gt;rename('bar');\n</code></pre> <p><code>$user1</code> and <code>$user2</code> reference the same object.</p> <pre><code>final class User\n{\n    public function __construct(\n        private string $name,\n    ) {}\n\n    public function rename(string $name): self\n    {\n        return new self($name);\n    }\n}\n</code></pre> <pre><code>$user1 = new User('foo');\n$user2 = $user1-&gt;rename('bar');\n</code></pre> <p><code>$user1</code> and <code>$user2</code> DO NOT reference the same object.</p>"},{"location":"terminology/","title":"Terminology","text":"<p>This ORM uses a specific terminlogy to reference behaviours and data structures. If your familiar with Domain-Driven Design, you should feel at home.</p>"},{"location":"terminology/#manager","title":"Manager","text":"<p>The <code>Manager</code> is the entrypoint to everything you can achieve with this ORM. It allows to:</p> <ul> <li>access repositories</li> <li>create transactions</li> </ul>"},{"location":"terminology/#adapter","title":"Adapter","text":"<p>An <code>Adapter</code> is the kind of storage you want to use. This is an object you need to create to pass as an argument to a <code>Manager</code>.</p> <p>This ORM comes buit-in with many adapters.</p>"},{"location":"terminology/#repository","title":"Repository","text":"<p>A <code>Repository</code> is kind of a big collection that represents all the aggregates of a given type. This is via this abstraction that you will persist and query your data.</p>"},{"location":"terminology/#transaction","title":"Transaction","text":"<p>This is the only place where you can modify the data inside a repository.</p> <p>A transaction is expressed via a <code>callable</code> passed to the manager, if the <code>callable</code> finishes successfully then all the modifications are committed to the storage otherwise they're rollbacked.</p> <p>The <code>callable</code> must return an <code>Either</code> monad where its right side is the only case where the transaction is considered successful. A left side or an exception is considered a failure.</p>"},{"location":"terminology/#aggregate","title":"Aggregate","text":"<p>It represents a root object to encapsulate data and behaviour. When accessing a repository this is this class you need to specify.</p> <p>An aggregate can contain properties like any object, required entities, optional entities and collections of entities.</p> <p>In order to be persisted all properties of aggregates and entities must be typed.</p>"},{"location":"terminology/#entity","title":"Entity","text":"<p>An <code>Entity</code> is a sub object solely owned by an <code>Aggregate</code> that needs to store properties. An entity can be:</p> <ul> <li>required: this means it always exist as long the aggregate exists and is a normal property of an aggregate</li> <li>optional: this means the entity is wrapped inside a <code>Maybe</code> monad</li> <li>in a collection: this means multiple entities of the same type are wrapped in a <code>Set</code> monad</li> </ul> <p>An entity can only contain properties, it can't contain other entities.</p> <p>You can use Enums as entities without the need to wrap them inside another class.</p>"},{"location":"terminology/#specification","title":"Specification","text":"<p>A <code>Specification</code> is the mechanism to create a filter. It's used to retrieve aggregates or remove them.</p> <p>It uses objects to represent:</p> <ul> <li>a comparison</li> <li>a negation</li> <li>an <code>and</code> composition of 2 specifications</li> <li>an <code>or</code> composition of 2 specifications</li> </ul> <p>In essence this boolean logic represented via objects. With them you can create almost any filter. And it enforces the precedence of operations (thus no implicits).</p>"},{"location":"adapters/","title":"Adapters","text":"<p>As you've seen throughout this documentation none of actions possible are dependent on a storage engine, all his abstracted away.</p> <p>This allows Formal to offer different storage adapters tailored to some use cases.</p> <p>This project uses Property Based Testing to make sure all the adapters behave the same way. This allows you to switch from one to another safely.</p>"},{"location":"adapters/elasticsearch/","title":"Elasticsearch","text":"<p>You should use this storage when you want a super fast search.</p>"},{"location":"adapters/elasticsearch/#setup","title":"Setup","text":"<pre><code>use Formal\\ORM\\{\n    Manager,\n    Adapter\\Elasticsearch,\n};\nuse Innmind\\OperatingSystem\\Factory;\nuse Innmind\\Url\\Url;\n\n$os = Factory::build(); //(1)\n$orm = Manager::of(\n    Elasticsearch::of(\n        $os-&gt;remote()-&gt;http(),\n        Url::of('http://localhost:9200/'), //(2)\n    ),\n);\n</code></pre> <ol> <li>See <code>innmind/operating-system</code>.</li> <li>If you use this exact url then you can omit this parameter.</li> </ol>"},{"location":"adapters/elasticsearch/#mapping","title":"Mapping","text":"<p>By default when you'll generate the mapping to create the Aggregate index (see below) Formal will adapt the field types for the PHP types it handles by default. For any other type it will use <code>text</code>.</p> <p>To avoid that you can declare the mapping for your custom types. For the <code>Name</code> you could do:</p> NameType.php<pre><code>use Formal\\ORM\\{\n    Definition\\Type,\n    Adapter\\Elasticsearch\\ElasticsearchType,\n};\nuse Formal\\AccessLayer\\Table\\Column;\n\n/**\n * @psalm-immutable\n * @implements Type&lt;Name&gt;\n */\nfinal class NameType implements Type, ElasticsearchType\n{\n    public function elasticsearchType(): array\n    {\n        return [\n            'type' =&gt; 'keyword', //(1)\n            'index' =&gt; false,\n        ];\n    }\n\n    public function normalize(mixed $value): null|string|int|bool\n    {\n        return $value-&gt;toString();\n    }\n\n    public function denormalize(null|string|int|bool $value): mixed\n    {\n        if (!\\is_string($value)) {\n            throw new \\LogicException(\"'$value' is not a string\");\n        }\n\n        return Name::of($value);\n    }\n}\n</code></pre> <ol> <li>See the documentation for an exhaustive list of types you can use.</li> </ol>"},{"location":"adapters/elasticsearch/#creating-indexes","title":"Creating indexes","text":"<p>To automatically create the index you can build a simple script like this:</p> show_create_tables.php<pre><code>use Formal\\ORM\\{\n    Definition\\Aggregates,\n    Definition\\Types,\n    Definition\\Type\\Support,\n    Adapter\\SQL\\ShowCreateTable,\n};\nuse Innmind\\OperatingSystem\\Factory;\nuse Innmind\\Url\\Url;\n\n$os = Factory::build(); //(1)\n$aggregates = Aggregates::of(Types::of(\n    Support::class(Name::class, new NameType),\n));\n$url = Url::of('http://localhost:9200/');\n$createIndex = CreateIndex::of(\n    $os-&gt;remote()-&gt;http(),\n    $aggregates,\n    $url,\n);\n$dropIndex = DropIndex::of(\n    $os-&gt;remote()-&gt;http(),\n    $aggregates,\n    $url,\n);\n\n$_ = $dropIndex(User::class)\n    -&gt;flatMap(static fn() =&gt; $createIndex(User::class))\n    -&gt;match(\n        static fn() =&gt; null, // index available\n        static fn() =&gt; throw new \\RuntimeException('Unable to create User index'),\n    );\n</code></pre> <ol> <li>See <code>innmind/operating-system</code>.</li> </ol>"},{"location":"adapters/elasticsearch/#testing","title":"Testing","text":"<p>If you want to test your app with integration tests against a real instance of Elasticsearch you should the <code>Refresh</code> HTTP transport. This decorator force Elasticsearch to apply changes directly to the index.</p> <pre><code>use Formal\\ORM\\{\n    Manager,\n    Adapter\\Elasticsearch,\n};\nuse Innmind\\OperatingSystem\\Factory;\nuse Innmind\\Url\\Url;\n\n$os = Factory::build();\n$orm = Manager::of(\n    Elasticsearch::of(\n        Elasticsearch\\Refresh::of(\n            $os-&gt;remote()-&gt;http(),\n        ),\n        Url::of('http://localhost:9200/'),\n    ),\n);\n</code></pre>"},{"location":"adapters/elasticsearch/#limitations","title":"Limitations","text":"<p>While this storage has its usages don't forget about its limitations.</p>"},{"location":"adapters/filesystem/","title":"Filesystem","text":"<p>This is the adapter you've been using since the start of this documentation.</p> <p>You can use any implementation of the <code>Innmind\\Filesystem\\Adapter</code> interface provided by <code>innmind/filesystem</code>.</p>"},{"location":"adapters/filesystem/#in-memory","title":"In memory","text":"<p>It allows to quickly iterate on some code and see if it works, and move later on on a more persistent storage.</p> <p>This adapter is also useful when testing an application. By using an in memory storage your tests can run faster as it doesn't have to persist anything to the filesystem.</p>"},{"location":"adapters/filesystem/#persistent","title":"Persistent","text":"<p>You can persist your aggregates to the filesystem via:</p> <pre><code>use Formal\\ORM\\Manager;\nuse Innmind\\Filesystem\\Adapter\\Filesystem;\nuse Innmind\\Url\\Path;\n\n$orm = Manager::filesystem(Filesystem::mount(Path::of('somewhere/')));\n</code></pre> <p>You should use this storage for proof of concept kind of apps. Or for small CLI apps you use locally.</p> <p>DO NOT use this storage for a production app. As this will be very slow and not concurrent safe.</p>"},{"location":"adapters/filesystem/#s3","title":"S3","text":"<p>The package <code>innmind/s3</code> exposes a filesystem adapter. You could use it like this:</p> <pre><code>use Formal\\ORM\\Manager;\nuse Innmind\\OperatingSystem\\Factory as OSFactory;\nuse Innmind\\S3\\{\n    Factory,\n    Region,\n    Filesystem\\Adapter,\n};\nuse Innmind\\Url\\Url;\n\n$os = OSFactory::build(); //(1)\n$bucket = Factory::of($os)-&gt;build(\n    Url::of('https://acces_key:acces_secret@bucket-name.s3.region-name.scw.cloud/'),\n    Region::of('region-name'),\n);\n\n$orm = Manager::filesystem(\n    Adapter::of($bucket),\n);\n</code></pre> <ol> <li>See <code>innmind/operating-system</code></li> </ol> <p>You should use this storage for proof of concept kind of apps. Or for small CLI apps and you want the storage to be available across multiple computers.</p> <p>DO NOT use this storage for a production app. As this will be very slow (due to network latency) and not concurrent safe.</p>"},{"location":"adapters/sql/","title":"SQL","text":"<p>You should use this storage for production mainly.</p>"},{"location":"adapters/sql/#setup","title":"Setup","text":"MySQL/MariaDBPostgreSQL <pre><code>use Formal\\ORM\\Manager;\nuse Innmind\\OperatingSystem\\Factory;\nuse Innmind\\Url\\Url;\n\n$os = Factory::build(); //(1)\n$orm = Manager::sql(\n    $os\n        -&gt;remote()\n        -&gt;sql(Url::of('mysql://user:password@127.0.0.1:3306/database_name')),\n);\n</code></pre> <ol> <li>See <code>innmind/operating-system</code>.</li> </ol> <pre><code>use Formal\\ORM\\Manager;\nuse Innmind\\OperatingSystem\\Factory;\nuse Innmind\\Url\\Url;\n\n$os = Factory::build(); //(1)\n$orm = Manager::sql(\n    $os\n        -&gt;remote()\n        -&gt;sql(Url::of('pgsql://user:password@127.0.0.1:5432/database_name')),\n);\n</code></pre> <ol> <li>See <code>innmind/operating-system</code>.</li> </ol>"},{"location":"adapters/sql/#mapping","title":"Mapping","text":"<p>By default when you'll generate the SQL to create the Aggregate tables (see below) Formal will adapt the column types for the PHP types it handles by default. For any other type it will use <code>LONGTEXT</code> with a comment suggesting you to modify this type.</p> <p>To avoid that you can declare the SQL type for your custom types. For the <code>Name</code> you could do:</p> NameType.php<pre><code>use Formal\\ORM\\{\n    Definition\\Type,\n    Adapter\\SQL\\SQLType,\n};\nuse Formal\\AccessLayer\\Table\\Column;\n\n/**\n * @psalm-immutable\n * @implements Type&lt;Name&gt;\n */\nfinal class NameType implements Type, SQLType\n{\n    public function sqlType(): Column\\Type\n    {\n        return Column\\type::varchar(100);\n    }\n\n    public function normalize(mixed $value): null|string|int|bool\n    {\n        return $value-&gt;toString();\n    }\n\n    public function denormalize(null|string|int|bool $value): mixed\n    {\n        if (!\\is_string($value)) {\n            throw new \\LogicException(\"'$value' is not a string\");\n        }\n\n        return Name::of($value);\n    }\n}\n</code></pre>"},{"location":"adapters/sql/#creating-tables","title":"Creating tables","text":"<p>To generate the SQL queries to create the tables you can build a simple script like this:</p> show_create_tables.php<pre><code>use Formal\\ORM\\{\n    Definition\\Aggregates,\n    Definition\\Types,\n    Definition\\Type\\Support,\n    Adapter\\SQL\\ShowCreateTable,\n};\nuse Formal\\AccessLayer\\Driver;\nuse Innmind\\OperatingSystem\\Factory;\n\n$os = Factory::build(); //(1)\n$aggregates = Aggregates::of(Types::of(\n    Support::class(Name::class, new NameType),\n));\n$show = ShowCreateTable::of($aggregates);\n\n$_ = $show(User::class)-&gt;foreach(\n    static fn($query) =&gt; print($query-&gt;sql(Driver::mysql).\";\\n\"),\n);\n</code></pre> <ol> <li>See <code>innmind/operating-system</code>.</li> </ol> <p>And if you run <code>php show_create_tables.php</code> it would output:</p> <pre><code>CREATE TABLE  `user` (`id` varchar(36) NOT NULL  COMMENT 'UUID', `name` varchar(100) NOT NULL  , PRIMARY KEY (`id`));\nCREATE TABLE  `user_addresses` (`aggregateId` varchar(36) NOT NULL  COMMENT 'UUID', `street` longtext NOT NULL  COMMENT 'TODO adjust the type depending on your use case', `zipCode` longtext NOT NULL  COMMENT 'TODO adjust the type depending on your use case', `city` longtext NOT NULL  COMMENT 'TODO adjust the type depending on your use case', CONSTRAINT `FK_user_addresses` FOREIGN KEY (`aggregateId`) REFERENCES `user`(`id`) ON DELETE CASCADE);\n</code></pre> Tip <p>You can call <code>$show-&gt;ifNotExists()(User::class)</code> to instead generate <code>CREATE TABLE IF NOT EXISTS</code> queries.</p> <p>Instead of printing the queries you can execute them directly like this:</p> show_create_tables.php<pre><code>use Formal\\ORM\\{\n    Definition\\Aggregates,\n    Definition\\Types,\n    Definition\\Type\\Support,\n    Adapter\\SQL\\ShowCreateTable,\n};\nuse Innmind\\OperatingSystem\\Factory;\nuse Innmind\\Url\\Url;\n\n$os = Factory::build(); //(1)\n$aggregates = Aggregates::of(Types::of(\n    Support::class(Name::class, new NameType),\n));\n$show = ShowCreateTable::of($aggregates);\n$connection = $os-&gt;remote()-&gt;sql(\n    Url::of('mysql://user:password@host:3306/database?charset=utf8mb4'),\n);\n\n$_ = $show(User::class)-&gt;foreach($connection);\n</code></pre>"},{"location":"adapters/sql/#migrations","title":"Migrations","text":"<p>While you still develop your app you can destroy and recreate your database when the schema change. But when you go to production you should use a migration tool to only update what's changed since the last deployment.</p> <p>You can use <code>formal/migrations</code> for this (and more).</p>"},{"location":"blog/","title":"Blog","text":"<p> RSS Feed</p>"},{"location":"blog/2024/10/adding-float-support-kinda/","title":"Adding <code>float</code> support (kinda...)","text":"<p>In the latest release Formal now allows to store <code>float</code>s in any storage.</p> <p>So far Formal didn't allow to use <code>float</code>s at the storage level on purpose. Handling this type is tricky due to the precision to use, rounding errors and implicit convertions.</p> <p>By avoiding to support it, it also avoided to bring associated bugs.</p> <p>However in certain cases we do need to store values as <code>float</code>s.</p> <p>In order to reconcile this need with the intention to not bring the associated bugs, Formal brings a partial support. It now allows to normalize a type to a <code>float</code> but it doesn't support <code>float</code> as a property type.</p> <p>This means that if you want to represent a tax for example you can't type your aggregate like this:</p> <pre><code>final readonly class SomeAggregate\n{\n    private Id $id;\n    private float $tax;\n}\n</code></pre> <p>By default Formal will ignore this property and won't store it. Instead you need to write a custom type:</p> <code>Tax</code><code>SomeAggregate</code><code>TaxType</code> <pre><code>final readonly class Tax\n{\n    public function __construct(\n        private float $value,\n    ) {}\n\n    public function toFloat(): float\n    {\n        return $this-&gt;value;\n    }\n}\n</code></pre> <pre><code>final readonly class SomeAggregate\n{\n    private Id $id;\n    private Tax $tax;\n}\n</code></pre> <pre><code>use Formal\\ORM\\Definition\\Type;\n\n/**\n * @psalm-immutable\n * @implements Type&lt;Tax&gt;\n */\nfinal class TaxType implements Type\n{\n    public function normalize(mixed $value): null|string|int|float|bool\n    {\n        return $value-&gt;toFloat();\n    }\n\n    public function denormalize(null|string|int|float|bool $value): mixed\n    {\n        if (!\\is_numeric($value)) { #(1)\n            throw new \\LogicException(\"'$value' is not a string\");\n        }\n\n        return new Tax($value + 0); #(2)\n    }\n}\n</code></pre> <ol> <li>In SQL the value will be read as a <code>string</code>.</li> <li>The <code>+ 0</code> allows to convert the <code>string</code> (when read from SQL) to either an <code>int</code> or <code>float</code> without changing the value.</li> </ol> <p>You can then implement <code>SQLType</code> or <code>ElasticsearchType</code> on <code>TaxType</code> to choose the precision to use at the storage level.</p> Note <p>You can't choose the precision for the Filesystem adapter as the value is stored as a JSON string.</p> <p>With this approach Formal let you use <code>float</code>s if you need to and at the same time forces you to think about the precision you want/need.</p> <p>You control what's happening, no implicits.</p>"},{"location":"blog/2024/07/aggregate-state-and-union-types/","title":"Aggregate state and union types","text":"<p>Let's launch this new documentation by showing how the new <code>Just</code> specification opens an interesting Aggregate design.</p> <p>A state can easily be described via an enum in an Aggregate property, and since <code>2.0.0</code> this is supported by default. But sometimes you need to attach extra information. Before <code>2.2.0</code>, even if technically possible, this is kind of messy type wise.</p> <p>Let's take the example of a <code>Blueprint</code> Aggregate for a house. This blueprint can be:</p> <ul> <li>in draft with the architect that last modified it</li> <li>pre-approved by an architect</li> <li>approved by both an architect and a client</li> </ul> <p>And we need to be able to list aggregates for one of those states.</p> <p>We could design it this way:</p> BlueprintStateArchitectClient <pre><code>use Formal\\ORM\\Id;\n\nfinal readonly class Blueprint\n{\n    /**\n     * @param Id&lt;self&gt; $id\n     * @param ?Id&lt;Architect&gt; $architect\n     * @param ?Id&lt;Client&gt; $client\n     */\n    private function __construct(\n        private Id $id,\n        private State $state,\n        private ?Id $architect,\n        private ?Id $client,\n    ) {}\n\n    /**\n     * @param Id&lt;Architect&gt; $archiect\n     */\n    public static function new(Id $archiect): self\n    {\n        return new self(\n            Id::new(self::class),\n            State::draft,\n            $architect,\n            null,\n        );\n    }\n\n    /**\n     * @param Id&lt;Architect&gt; $architect\n     */\n    public function preApprove(Id $architect): self\n    {\n        return new self(\n            $this-&gt;id,\n            State::preApproved,\n            $architect,\n            $this-&gt;client,\n        );\n    }\n\n    /**\n     * @param Id&lt;Client&gt; $client\n     */\n    public function approve(Id $client): self\n    {\n        return new self(\n            $this-&gt;id,\n            State::preApproved,\n            $this-&gt;architect,\n            $client,\n        );\n    }\n\n    public function doStuff(): void\n    {\n        match ($this-&gt;state) {\n            State::draft =&gt; null, // todo\n            State::preApproved =&gt; null, // todo\n            State::approved =&gt; null, // todo\n        };\n    }\n}\n</code></pre> <pre><code>enum State\n{\n    case draft;\n    case preApproved;\n    case approved;\n}\n</code></pre> <pre><code>final readonly class Architect\n{\n    /**\n     * @param Id&lt;self&gt; $id\n     */\n    public function __construct(\n        private Id $id,\n    ) {}\n}\n</code></pre> <p>This is a dummy aggregate only here for the example.</p> <pre><code>final readonly class Client\n{\n    /**\n     * @param Id&lt;self&gt; $id\n     */\n    public function __construct(\n        private Id $id,\n    ) {}\n}\n</code></pre> <p>This is a dummy aggregate only here for the example.</p> <p>You can easily query aggregates by state via a simple specification on the <code>state</code> property.</p> <p>However type wise this is not great because in the <code>Blueprint::doStuff()</code> method Psalm can't know that for each state the associated properties are not <code>null</code>. You need to either add extra null checks that are useless or add <code>@psalm-suppress</code> annotations that may hide real errors in the future.</p> <p>With <code>2.2.0</code> we can redesign the aggregate this way:</p> BlueprintDraftPreApprovedApproved <pre><code>use Formal\\ORM\\{\n    Id,\n    Definition\\Contains,\n};\nuse Innmind\\Immutable\\Maybe;\n\nfinal readonly class Blueprint\n{\n    /**\n     * @param Id&lt;self&gt; $id\n     * @param Maybe&lt;Draft&gt; $draft\n     * @param Maybe&lt;PreApproved&gt; $preApproved\n     * @param Maybe&lt;Approved&gt; $approved\n     */\n    private function __construct(\n        private Id $id,\n        #[Contains(Draft::class)]\n        private Maybe $draft,\n        #[Contains(PreApproved::class)]\n        private Maybe $preApproved,\n        #[Contains(Approved::class)]\n        private Maybe $approved,\n    ) {}\n\n    /**\n     * @param Id&lt;Architect&gt; $archiect\n     */\n    public static function new(Id $archiect): self\n    {\n        return new self(\n            Id::new(self::class),\n            Maybe::just(new Draft($architect)),\n            Maybe::nothing(),\n            Maybe::nothing(),\n        );\n    }\n\n    /**\n     * @param Id&lt;Architect&gt; $architect\n     */\n    public function preApprove(Id $architect): self\n    {\n        return new self(\n            $this-&gt;id,\n            Maybe::nothing(),\n            Maybe::just(new PreApproved($architect)),\n            $this-&gt;approved,\n        );\n    }\n\n    /**\n     * @param Id&lt;Client&gt; $client\n     */\n    public function approve(Id $client): self\n    {\n        $architect = $this-&gt;preApproved-&gt;match(\n            static fn($preApproved) =&gt; $preApproved-&gt;architect(),\n            static fn() =&gt; throw new \\LogicException('Not pre-approved'),\n        );\n\n        return new self(\n            $this-&gt;id,\n            Maybe::nothing(),\n            Maybe::nothing(),\n            Maybe::just(new Approved($architect, $client)),\n        );\n    }\n\n    public function doStuff(): void\n    {\n        $state = $this\n            -&gt;draft\n            -&gt;otherwise(fn() =&gt; $this-&gt;preApproved)\n            -&gt;otherwise(fn() =&gt; $this-&gt;approved)\n            -&gt;match(\n                static fn($state) =&gt; $state,\n                static fn() =&gt; throw new \\LogicException('Not reachable'),\n            );\n\n        match (true) {\n            $state instanceof Draft =&gt; $state-&gt;architect(),\n            $state instanceof PreApproved =&gt; $state-&gt;architect(),\n            $state instanceof Approved =&gt; $state-&gt;client(),\n        };\n    }\n}\n</code></pre> <pre><code>use Formal\\ORM\\Id;\n\nfinal readonly class Draft\n{\n    /**\n     * @param Id&lt;Architect&gt; $architect\n     */\n    public function __construct(\n        private Id $architect,\n    ) {}\n\n    /**\n     * @return Id&lt;Architect&gt;\n     */\n    public function architect(): Id\n    {\n        return $this-&gt;architect;\n    }\n}\n</code></pre> <pre><code>use Formal\\ORM\\Id;\n\nfinal readonly class PreApproved\n{\n    /**\n     * @param Id&lt;Architect&gt; $architect\n     */\n    public function __construct(\n        private Id $architect,\n    ) {}\n\n    /**\n     * @return Id&lt;Architect&gt;\n     */\n    public function architect(): Id\n    {\n        return $this-&gt;architect;\n    }\n}\n</code></pre> <pre><code>use Formal\\ORM\\Id;\n\nfinal readonly class Approved\n{\n    /**\n     * @param Id&lt;Architect&gt; $architect\n     * @param Id&lt;Client&gt; $client\n     */\n    public function __construct(\n        private Id $architect,\n        private Id $client,\n    ) {}\n\n    /**\n     * @return Id&lt;Client&gt;\n     */\n    public function client(): Id\n    {\n        return $this-&gt;client;\n    }\n}\n</code></pre> <p>This new design has 2 benefits:</p> <ul> <li>in the <code>approve</code> method we are forced to explicit the previous state to access the architect</li> <li>in the <code>doStuff</code> method Psalm is now aware that the ids exist in each state</li> </ul> <p>And it can be queried via this specification:</p> <pre><code>use Formal\\ORM\\Specification\\Just;\nuse Innmind\\Specification\\{\n    Comparator,\n    Composable,\n    Sign,\n};\n\n/**\n * @psalm-immutable\n */\nfinal readonly class State implements Comparator\n{\n    use Composable;\n\n    public static function draft(): Just\n    {\n        return Just::of('draft', new self);\n    }\n\n    public static function preApproved(): Just\n    {\n        return Just::of('preApproved', new self);\n    }\n\n    public static function approved(): Just\n    {\n        return Just::of('approved', new self);\n    }\n\n    public function property(): string\n    {\n        return 'architect';\n    }\n\n    public function sign(): Sign\n    {\n        return Sign::isNotNull;\n    }\n\n    public function value(): mixed\n    {\n        return null;\n    }\n}\n</code></pre> <p>By checking the <code>architect</code> is not null allows to check if the entity exist in the storage.</p>"},{"location":"getting-started/","title":"Getting started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<pre><code>composer require formal/orm\n</code></pre>"},{"location":"getting-started/#setup","title":"Setup","text":"Ephemeral storagePersistent storage <pre><code>use Formal\\ORM\\Manager;\nuse Innmind\\Filesystem\\Adapter\\InMemory;\n\n$orm = Manager::filesystem(InMemory::emulateFilesystem());\n</code></pre> <pre><code>use Formal\\ORM\\Manager;\nuse Innmind\\Filesystem\\Adapter\\Filesystem;\nuse Innmind\\Url\\Path;\n\n$orm = Manager::filesystem(Filesystem::mount(Path::of('some/directory/')));\n</code></pre> <p>In the rest of this documentation the variable <code>$orm</code> will reference this <code>Manager</code> object.</p> <p>While you learn how to use this ORM the filesystem storage is enough, you'll learn later on how to use other adapters. As the examples names suggest one is ephemeral meaning nothing is persisted to the filesystem allowing you to run your code without side effects. On the other hand the persistent storage will store the data to your filesystem and you'll need to delete the data when the aggregate class will change.</p>"},{"location":"getting-started/aggregate/","title":"Create an aggregate","text":"<p>Throughout this documentation you'll learn how to persist a <code>User</code> aggregate. For now this aggregate will only have an id and a name:</p> User.php<pre><code>use Formal\\ORM\\Id;\n\nfinal readonly class User\n{\n    /**\n     * @param Id&lt;self&gt; $id\n     */\n    private function __construct(\n        private Id $id,\n        private string $name,\n    ) {}\n\n    public static function new(string $name): self\n    {\n        return new self(Id::new(self::class), $name);\n    }\n\n    public function name(): string\n    {\n        return $this-&gt;name;\n    }\n}\n</code></pre> <p>There's not much code but there's already much to know!</p> <p>The class is declared <code>readonly</code> to make sure once it's instanciated it can't be modified. This the immutability required for the ORM to work properly. (1)</p> <ol> <li>If you use Psalm you can also add the <code>@psalm-immutable</code> annotation on the class.</li> </ol> <p>An aggregate must have an <code>$id</code> property with the type <code>Formal\\ORM\\Id</code>. It's this property that uniquely reference an aggregate in the storage. (You'll also see in the next chapter how the ORM uses it internally).</p> <p><code>Id::new()</code> will generate a brand new value (1). The class passed as argument allows Psalm to know to which aggregate type it belongs to, this prevents you from mistakenly use an id of an aggregate A when trying to retrieve an aggregate B.</p> <ol> <li>Internally it uses uuids.</li> </ol> <p>For now we'll only use this <code>string</code> property, you'll learn in the mapping chapter how to use more complex types.</p> Tip <p>In this example we use a private constructor that list all properties and a public named constructor. While this design is not mandatory it will be clearer to see what's happening when you'll modify the aggregate.</p> <p>Also note that the ORM does not need your aggregate constructor to be public in order to instanciate objects coming from the storage.</p>"},{"location":"getting-started/count/","title":"Count aggregates","text":"<p>At some point you may need to count the number of aggregates stored. You can do it like this:</p> <pre><code>$count = $orm-&gt;repository(User::class)-&gt;size();\n</code></pre> <p>This will return <code>0</code> or more.</p> <p>And sometime you may need to simply know if there's at least one aggregate or none. For this case you should not use the <code>size</code> method as it overfetches data. Instead you can do:</p> <pre><code>$trueWhenTheresAtLeastOneUser = $orm-&gt;repository(User::class)-&gt;any();\n// or\n$trueWhenTheresNoUser = $orm-&gt;repository(User::class)-&gt;none();\n</code></pre> Note <p>If you want to count the number of aggregates corresponding to a set of criteria head to the Specification chapter.</p>"},{"location":"getting-started/persist/","title":"Persist an aggregate","text":"<p>In order to persist an aggregate you need 3 things:</p> <ul> <li>an instance of the aggregate</li> <li>a repository in which to put the aggregate</li> <li>a transaction to atomically persist the aggregate</li> </ul> <p>Translated into code this gives:</p> <pre><code>use Innmind\\Immutable\\Either;\n\n$user = User::new('alice');\n$users = $orm-&gt;repository(User::class);\n$result = $orm-&gt;transactional(\n    static function() use ($repository, $user) {\n        $repository-&gt;put($user);\n\n        return Either::right(null);\n    };\n);\n</code></pre> <p>Once again not much code but a lot to learn.</p> <p>The <code>$user</code> aggregate here is instanciated outside the transaction. It's simple PHP that is not aware of the ORM and the transaction, this means you can instanciate your aggregates anywhere you want in your app.</p> <p>The <code>$users</code> repository is the abstraction that represent all users in the storage. It's when you call the <code>$orm-&gt;repository()</code> method that the ORM will scan the aggregate class to learn how to persist it.</p> <p>You should only call this method once per aggregate type and then keep it in memory, as this scan will slow your app if you do it many times. However if your app is in a long living process and you want your memory footprint to be as low as possible you may want to dereference the repository and rebuild it upon use.</p> <p>Use your best judgment to choose the best option for your need.</p> <p><code>$orm-&gt;transactional()</code> will start a transaction via the storage used by the ORM. It will then call the callable you passed to it. If the returned value is an <code>Either</code> with a value on the right side it will commit the transaction and return the <code>Either</code> object as the <code>$result</code> variable. If the <code>Either</code> contains a value on the left side it will rollback the transaction and return the <code>Either</code> object as the <code>$result</code> variable. If the callable throws an exception it will rollback as well an rethrow the exception.</p> <p><code>$repository-&gt;put()</code> will call the storage to persist the aggregate. At this point the ORM knows to create the aggregate because it's unaware before that of its <code>Id</code> object reference. After the <code>put</code> the ORM is now aware of this id and if you do another <code>put</code> it will try to update the same entry in the storage. (1)</p> <ol> <li>That's why you can't clone an <code>Id</code> object as the ORM would no longer know if it needs to insert or update the aggregate.</li> </ol> <p>Finally we return <code>Either::right(null)</code> to tell the ORM to commit the transaction. We use <code>null</code> because there's no business logic done here. But you could imagine returning a computed value instead, or return a business error object on the left side of the <code>Either</code>.</p> <p>This example only persist one aggregate but you can persist as many as you want.</p> <p>If you try to call <code>put</code> outside of a transaction it will throw an exception. This is a design choice to prevent an accidental modification to your storage outside of an expected transaction.</p> <p>This forces an application design to be more explicit in where a modification can happen.</p> <p>Also the <code>put</code> here is done directly inside the callable, but it can happen anywhere in a call stack that originated from this callable.</p>"},{"location":"getting-started/remove/","title":"Remove an aggregate","text":"<p>In order to remove an aggregate you need 3 things:</p> <ul> <li>an <code>Id</code> of the aggregate</li> <li>a repository in which to put the aggregate</li> <li>a transaction to atomically persist the aggregate</li> </ul> <p>Translated into code this gives:</p> <pre><code>use Innmind\\Immutable\\Either;\n\n$users = $orm-&gt;repository(User::class);\n$result = $orm-&gt;transactional(\n    static function() use ($repository) {\n        $repository-&gt;remove(Id::of(User::class, 'alice-uuid'));\n\n        return Either::right(null);\n    };\n);\n</code></pre> <p>If alice exists in the storage it will remove it and if it doesn't then nothing will happen. And like for persisting the <code>Either::right(null)</code> will indicate to <code>transactional</code> to commit the transaction.</p> Note <p>If you want to remove multiple aggregates at once corresponding to a set of criteria head to the Specification chapter.</p>"},{"location":"getting-started/retrieve/","title":"Retrieve an aggregate","text":"<p>Once an aggregate has been persisted you'll want to load it at some point.</p> <p>The easiest way to retrieve it is to load all aggregates and filter the one you want:</p> <pre><code>$alice = $orm\n    -&gt;repository(User::class)\n    -&gt;all()\n    -&gt;find(static fn(User $user) =&gt; $user-&gt;name() === 'alice')\n    -&gt;match(\n        static fn(User $user) =&gt; $user,\n        static fn() =&gt; null,\n    );\n</code></pre> <p>If there's an <code>alice</code> user in the storage then <code>$alice</code> will be an instance of <code>User</code> otherwise it will be <code>null</code>.</p> Note <p>Note that you don't need to be in a transaction to fetch your aggregates.</p> <p>While this example is simple enough it's not very performant as it loads every aggregate from the storage until it finds alice. The better approach is to directly fetch alice via its id:</p> <pre><code>$alice = $orm\n    -&gt;repository(User::class)\n    -&gt;get(Id::of(User::class, 'alice-uuid'))\n    -&gt;match(\n        static fn(User $user) =&gt; $user,\n        static fn() =&gt; null,\n    );\n</code></pre> <p>Here we use <code>alice-uuid</code> as the id value but this is a placeholder. You should replace it with the real id value, usually it will come from a HTTP route parameter.</p> Info <p>An <code>Id</code> can be transformed to a string via the <code>$id-&gt;toString()</code> method.</p> <p>The <code>get</code> method returns a <code>Maybe&lt;User&gt;</code> as the corresponding user may not exist in the storage. Here we return <code>null</code> if alice doesn't exist but you can return or call any code you'd like.</p> Note <p>If you want to learn how to retrieve mutliple aggregates corresponding to a set of criteria head to the Specification chapter.</p> Note <p>Note that the monads are lazy evaluated when retrieving data. This means that it will hit the storage only when trying to extract data from them and will only load one aggregate at a time.</p> <p>For a <code>Maybe</code> this means calling <code>match</code> or <code>memoize</code>. For a <code>Sequence</code> it's all methods marked with  in its documentation.</p>"},{"location":"getting-started/update/","title":"Update an aggregate","text":"<p>Now that you know howto load aggregates from the storage let's say that for some reason you want to rename <code>alice</code> to <code>bob</code>. The first part is to add a new method on our <code>User</code>:</p> User.php<pre><code>use Formal\\ORM\\Id;\n\nfinal readonly class User\n{\n    /**\n     * @param Id&lt;self&gt; $id\n     */\n    private function __construct(\n        private Id $id,\n        private string $name,\n    ) {}\n\n    public static function new(string $name): self\n    {\n        return new self(Id::new(self::class), $name);\n    }\n\n    public function name(): string\n    {\n        return $this-&gt;name;\n    }\n\n    public function rename(string $name): self\n    {\n        return new self($this-&gt;id, $name);\n    }\n}\n</code></pre> <p>Since our aggregate is readonly we need to return a new instance. The only difference in the new <code>User</code> object is the new name.</p> Tip <p>The private constructor shines here because it forces a new instance to specify all the previous properties that don't change. This without the public api to know how the internal object behaves, so far nobody outside the class knows there's an <code>id</code> property.</p> <p>Specifying each property to instanciate a new version of the aggregate can be seen as repetitive and tiring but this is intended to provide a wake up call. If you need to write 50(1) properties for each modifier method, then maybe your class tries to do to much and should be refactored or split up.</p> <ol> <li>(this is an arbitrary number)</li> </ol> <p>Also you should not provide default values to the <code>__construct</code> parameters, this will help make sure you didn't forget to copy any property (that would result in a state change).</p> <p>In the end you may still be tempted to use <code>clone</code>. Know that this will work as it doesn't change a thing for the ORM. Yet this practice is frowned upon by this project as it favors implicits.</p> <p>And then apply our change:</p> <pre><code>use Formal\\ORM\\Id;\nuse Innmind\\Immutable\\Either;\n\n$repository = $orm-&gt;repository(User::class);\n$orm-&gt;transactional(\n    static function() use ($repository) {\n        $_ = $repository\n            -&gt;get(Id::of(User::class, 'alice-uuid'))\n            -&gt;map(static fn(User $alice) =&gt; $alice-&gt;rename('bob'))\n            -&gt;match(\n                static fn(User $bob) =&gt; $repository-&gt;put($bob),\n                static fn() =&gt; null,\n            );\n\n        return Either::right(null);\n    },\n);\n</code></pre> <p>As seen before we fetch alice via its id, if the object exist then the callable passed to <code>map</code> is called. Then in <code>match</code> either we have the new <code>User</code> object representing bob and persist it again or we do nothing by returning <code>null</code>.</p> <p>Notice that we need to call the repository to make it aware of alice being renamed to bob. This is because the objects are immutable so it can't magically know about the new object. This may seem like extra work but this is intentional to prevent any accidental persisting of a partially modified entity, everything is explicit.</p> <p>Also notice that we use the same method <code>put</code> as inserting a brand new aggregate. The ORM knows that it needs to do an update because it's aware of the <code>Id</code> reference since it build it when fetching alice.</p> <p>And like for persisting an aggregate we return <code>Either::right(null)</code> to commit the transaction, even if alice doesn't exist.</p> Tip <p>If you feel the example is a bit verbose we can shorten it like this:</p> <pre><code>use Formal\\ORM\\Id;\n\n$repository = $orm-&gt;repository(User::class);\n$orm-&gt;transactional(\n    static fn() =&gt; $repository\n        -&gt;get(Id::of(User::class, 'alice-uuid'))\n        -&gt;map(static fn(User $alice) =&gt; $alice-&gt;rename('bob'))\n        -&gt;map($repository-&gt;put(...))\n        -&gt;either(),\n    },\n);\n</code></pre> <p>This does the same thing except one thing. If alice doesn't exist it will rollback the transaction instead of committing it, but this doesn't change the end result.</p> <p><code>-&gt;map($repository-&gt;put(...))</code> this will call the <code>put</code> method if there was an alice that has been renamed to bob on the line before. </p> <p><code>-&gt;either()</code> this transforms the <code>Maybe&lt;void&gt;</code> to an <code>Either&lt;null, void&gt;</code>. The <code>void</code> type is the return type of the <code>put</code> method and the <code>null</code> is when alice doesn't exist. That's why we rollback if alice doesn't exist, the returned <code>Either</code> contains <code>null</code> on the left side.</p> <p>Also note that all this is lazy evaluated, the <code>get</code> and eventually <code>put</code> occur when <code>transactional</code> checks the <code>Either</code> returned by the callable.</p>"},{"location":"mapping/","title":"Mapping","text":"<p>So far the <code>User</code> aggregate only contains a <code>string</code> property. By default Formal also supports these primitive types:</p> <ul> <li><code>bool</code></li> <li><code>int</code></li> <li><code>string</code></li> <li><code>?bool</code></li> <li><code>?int</code></li> <li><code>?string</code></li> </ul> <p>Using primitive types is fine when you prototype the design of your aggregates. But you SHOULD use dedicated classes for each kind of value to better convey meaning and expected behaviour, this is what Typing is truely about. (1)</p> <ol> <li>It also has the benefit to immensely simplify refactoring your code.</li> </ol> <p>Types are essential in the Formal design. You'll learn in the next chapter how to support your custom types.</p> <p>By default Formal also supports:</p> <ul> <li><code>Innmind\\Immutable\\Str</code> from <code>innmind/immutable</code> (1)</li> <li><code>Innmind\\TimeContinuum\\PointInTime</code> from <code>innmind/time-continuum</code></li> </ul> <ol> <li>Beware! It won't store the encoding, when fetched it will use <code>Innmind\\Immutable\\Str\\Encoding::utf8</code></li> </ol> Note <p>Formal can support the <code>PointInTime</code> type but you still need to declare it like this:</p> <pre><code>use Formal\\ORM\\{\n    Manager,\n    Definition\\Aggregates,\n    Definition\\Types,\n    Definition\\Type\\Support,\n    Definition\\Type\\PointInTimeType,\n};\nuse Innmind\\TimeContinuum\\PointInTime;\n\n$orm = Manager::of(\n    /* any adapter (1) */,\n    Aggregates::of(\n        Types::of(\n            Support::class(\n                PointInTime::class,\n                PointInTimeType::new($os-&gt;clock()),\n            ),\n        ),\n    ),\n);\n</code></pre> <ol> <li>See the Adapters chapter to see all the adapters you can use.</li> </ol> <p>The <code>$os</code> variable comes from the <code>innmind/operating-system</code> package.</p>"},{"location":"mapping/collections/","title":"Collection of entities","text":"<p>Another common use cases could be to have an unknown number of entities. Our <code>User</code> may want to specify multiple addresses.</p> <p>You can do it like this:</p> User.php<pre><code>use Formal\\ORM\\{\n    Id,\n    Definition\\Contains,\n};\nuse Innmind\\Immutable\\Set;\n\nfinal readonly class User\n{\n    /**\n     * @param Id&lt;self&gt; $id\n     * @param Set&lt;Address&gt; $address\n     */\n    private function __construct(\n        private Id $id,\n        private Name $name,\n        #[Contains(Address::class)]\n        private Set $addresses,\n    ) {}\n\n    public static function new(Name $name): self\n    {\n        return new self(Id::new(self::class), $name, Set::of());\n    }\n\n    public function name(): Name\n    {\n        return $this-&gt;name;\n    }\n\n    public function rename(Name $name): self\n    {\n        return new self($this-&gt;id, $name, $this-&gt;addresses);\n    }\n\n    public function addAddress(Address $address): self\n    {\n        return new self(\n            $this-&gt;id,\n            $this-&gt;name,\n            $this-&gt;addresses-&gt;add($address),\n        );\n    }\n}\n</code></pre> <p>This is very similar to optional entities.</p> <p>The <code>Set</code> monad represents an unordered collection of unique values.</p> Warning <p>When a <code>Set</code> contains objects, the uniqueness is defined by the reference of the objects and not their values.</p> <p>This means that these 2 sets are not the same:</p> <pre><code>$address = new Address('foo', 'bar', 'baz');\n$set1 = Set::of($address, $address);\n$set2 = Set::of(\n    new Address('foo', 'bar', 'baz'),\n    new Address('foo', 'bar', 'baz'),\n);\n</code></pre> <p><code>$set1</code> only contains 1 <code>Address</code> while <code>$set2</code> contains 2.</p> Note <p>If you're not familiar with the <code>Set</code> monad you can head to this documentation describing all its methods.</p>"},{"location":"mapping/entities/","title":"Entities","text":"<p>The <code>User</code> name represent a single value and you now know to handle this kind of property. But at some point you'll need to use an object that has multiple properties.</p> <p>This kind of object is called an Entity.</p> <p>An example for a user would be an <code>Address</code>:</p> Address.php<pre><code>final readonly class Address\n{\n    public function __construct(\n        private string $street,\n        private string $zipCode,\n        private string $city,\n    ) {}\n\n    // (1)\n}\n</code></pre> <ol> <li>No methods such as getters for conciseness of the example.</li> </ol> <p>And to use it in <code>User</code>:</p> User.php<pre><code>use Formal\\ORM\\Id;\n\nfinal readonly class User\n{\n    /**\n     * @param Id&lt;self&gt; $id\n     */\n    private function __construct(\n        private Id $id,\n        private Name $name,\n        private Address $address,\n    ) {}\n\n    public static function new(Name $name, Address $address): self\n    {\n        return new self(Id::new(self::class), $name, $address);\n    }\n\n    public function name(): Name\n    {\n        return $this-&gt;name;\n    }\n\n    public function rename(Name $name): self\n    {\n        return new self($this-&gt;id, $name, $this-&gt;address);\n    }\n}\n</code></pre> <p>And that's it!</p> <p>Thanks to immutability Formal knows for sure that an <code>Address</code> only belongs to a <code>User</code>, so no need for the <code>Address</code> to have an id.</p> Warning <p>Formal's implementation, while providing a high level abstraction, aims to remain simple.</p> <p>For that reason only an Aggregate can have entities. You can't define an Entity inside an Entity!</p> <p>This choice is also to force you to really think about the design of your aggregates. If you try to nest entities then maybe you're not using the right approach. And if you really want to use nesting then Formal is not the right abstraction!</p>"},{"location":"mapping/optionals/","title":"Optional entities","text":"<p>In the previous chapter you've seen what an Entity is. But an Entity can't always be required!</p> <p>For our example, not every <code>User</code> wan't to specify an <code>Address</code>.</p> <p>This is how you make it optional:</p> User.php<pre><code>use Formal\\ORM\\{\n    Id,\n    Definition\\Contains,\n};\nuse Innmind\\Immutable\\Maybe;\n\nfinal readonly class User\n{\n    /**\n     * @param Id&lt;self&gt; $id\n     * @param Maybe&lt;Address&gt; $address\n     */\n    private function __construct(\n        private Id $id,\n        private Name $name,\n        #[Contains(Address::class)]\n        private Maybe $address,\n    ) {}\n\n    public static function new(Name $name): self\n    {\n        return new self(Id::new(self::class), $name, Maybe::nothing());\n    }\n\n    public function name(): Name\n    {\n        return $this-&gt;name;\n    }\n\n    public function rename(Name $name): self\n    {\n        return new self($this-&gt;id, $name, $this-&gt;address);\n    }\n\n    public function addAddress(Address $address): self\n    {\n        return new self(\n            $this-&gt;id,\n            $this-&gt;name,\n            Maybe::just($address),\n        );\n    }\n}\n</code></pre> <p>The <code>#[Contains(Address::class)]</code> tells Formal the kind of Entity contained inside the <code>Maybe</code>.</p> <p>The <code>Maybe</code> monad is a way to describe the possible absence of data. This is kind of a nullable type.</p> Note <p>Formal doesn't use <code>null</code> to represent the possible absence of an Entity as it would force it to load all optional entities when fetching the aggregate.</p> <p>With <code>Maybe</code> it can lazy load them when first used after fetching an aggregate from the storage.</p> <p>If you're not familiar with the <code>Maybe</code> monad you can start learning it here. You can follow up by reading this documentation describing all its methods.</p> Info <p>The <code>Contains</code> attribute is here to avoid to have to parse the docblock to extract the information specified for static analysis tools such as Psalm.</p> <p>If a standard emerges between static analysis tools in attributes to specify this kind of information then Formal may migrate to it.</p>"},{"location":"mapping/type/","title":"Custom type","text":"<p>The <code>User</code> name is typed with a <code>string</code>. This means that it can be empty. Let's introduce the <code>Name</code> type to make sure it's never empty:</p> Name.php<pre><code>final readonly class Name\n{\n    private function __construct(\n        private string $value,\n    ) {}\n\n    public static function of(string $value): self\n    {\n        return match ($value) {\n            '' =&gt; throw new \\LogicException('The name cannot be empty'),\n            default =&gt; new self($value),\n        };\n    }\n\n    public function toString(): string\n    {\n        return $this-&gt;value;\n    }\n}\n</code></pre> <p>We can now refactor the <code>User</code> like this:</p> User.php<pre><code>use Formal\\ORM\\Id;\n\nfinal readonly class User\n{\n    /**\n     * @param Id&lt;self&gt; $id\n     */\n    private function __construct(\n        private Id $id,\n        private Name $name,\n    ) {}\n\n    public static function new(Name $name): self\n    {\n        return new self(Id::new(self::class), $name);\n    }\n\n    public function name(): Name\n    {\n        return $this-&gt;name;\n    }\n\n    public function rename(Name $name): self\n    {\n        return new self($this-&gt;id, $name);\n    }\n}\n</code></pre> <p>And just like that the <code>User</code> can't have an empty name.</p> <p>But for Formal to properly store this <code>Name</code> we need to tell it how to convert the object to a primitive value and vice-versa.</p> NameType.php<pre><code>use Formal\\ORM\\Definition\\Type;\n\n/**\n * @psalm-immutable\n * @implements Type&lt;Name&gt;\n */\nfinal class NameType implements Type\n{\n    public function normalize(mixed $value): null|string|int|float|bool\n    {\n        return $value-&gt;toString();\n    }\n\n    public function denormalize(null|string|int|float|bool $value): mixed\n    {\n        if (!\\is_string($value)) {\n            throw new \\LogicException(\"'$value' is not a string\");\n        }\n\n        return Name::of($value);\n    }\n}\n</code></pre> <p><code>@implements Type&lt;Name&gt;</code> allows Psalm to know that the <code>$value</code> argument of <code>normalize</code> is always a <code>Name</code> (despite it's <code>mixed</code> type), and the return type of <code>denormalize</code> must also be a <code>Name</code>.</p> <p>And lastly tell the ORM about this type converter:</p> <pre><code>use Formal\\ORM\\{\n    Manager,\n    Definition\\Aggregates,\n    Definition\\Types,\n    Definition\\Type\\Support,\n}\n\n$orm = Manager::of(\n    /* any adapter (1) */,\n    Aggregates::of(\n        Types::of(\n            Support::class(Name::class, new NameType),\n        ),\n    ),\n);\n</code></pre> <ol> <li>See the Adapters chapter to see all the adapters you can use.</li> </ol> <p>With this you can also use the <code>?Name</code> type on a property.</p> <p>Formal handles the <code>null</code> case for you!</p>"},{"location":"specifications/","title":"Specifications","text":"<p>Specifications is a pattern to describe a tree of conditions. It's composed of:</p> <ul> <li>a way to describe a comparison</li> <li>an <code>AND</code> gate</li> <li>an <code>OR</code> gate</li> <li>a <code>NOT</code> gate</li> </ul> <p>This is the basis of boolean logic.</p> <p>The big advantage is that a specification can be translated to many languages: pure PHP, SQL, Elasticsearch query, and more...</p> <p>That's why Formal uses them to target multiple aggregates, it allows to provide multiple storages and still be optimized for all of them.</p> <p>Another big advantage is that they compose very easily. This allows to both abstract complex queries behind a domain semantic and tweak a query locally for a specific use case without having to duplicate the whole query.</p>"},{"location":"specifications/count/","title":"Count multiple aggregates","text":"<p>You can count aggregates by retrieving them and count the elements in the returned sequence like this:</p> <pre><code>$numberOfAlices = $orm\n    -&gt;repository(User::class)\n    -&gt;matching(\n        SearchByName::of(Name::of('alice')),\n    )\n    -&gt;sequence()\n    -&gt;size();\n</code></pre> <p>But you MUST NOT do this. This will fetch the aggregates in memory and count them in PHP, this will be extremely slow!</p> <p>The right approach is:</p> <pre><code>$numberOfAlices = $orm\n    -&gt;repository(User::class)\n    -&gt;size(\n        SearchByName::of(Name::of('alice')),\n    );\n</code></pre> <p>This will run an optimized count in your storage.</p> <p>But if you only need to know if there's an aggregate in the storage matching the specification, you SHOULD do:</p> <pre><code>$numberOfAlices = $orm\n    -&gt;repository(User::class)\n    -&gt;any(\n        SearchByName::of(Name::of('alice')),\n    );\n</code></pre> <p>This runs an even more optimized query against your storage.</p> <p>And if you need to make sure no aggregate matches a specification:</p> <pre><code>$numberOfAlices = $orm\n    -&gt;repository(User::class)\n    -&gt;none(\n        SearchByName::of(Name::of('alice')),\n    );\n</code></pre> Tip <p>The specification passed to <code>any</code> and <code>none</code> is optional, allowing you to know if there at least one aggregate or none (as the name would suggest).</p>"},{"location":"specifications/cross-matching/","title":"Matching across aggregates","text":"<p>You can match aggregates of some kind based on conditions from another aggregate kind.</p> <p>For example if you have 2 aggregates <code>User</code> and <code>Movie</code> and you want:</p> <p>All movies where the director's last name is Blomkamp.</p> <p>You can write the following code:</p> <pre><code>use Innmind\\Specification\\{\n    Comparator\\Property,\n    Sign,\n};\n\n$orm\n    -&gt;repository(Movie::class)\n    -&gt;matching(Property::of(\n        'director',\n        Sign::in,\n        $orm\n            -&gt;repository(User::class)\n            -&gt;matching(Property::of(\n                'lastName',\n                Sign::equality,\n                'Blomkamp',\n            )),\n    ))\n    -&gt;foreach(static fn($movie) =&gt; doSomething($movie));\n</code></pre> <p>For this to work the <code>director</code> property must be typed <code>Formal\\ORM\\Id&lt;User&gt;</code>.</p> <p>If your storage adapter supports it this is even optimised at the storage level.</p> Warning <p>Only SQL is able to optimize this at the storage level.</p> <p>It still works with Elasticsearch and Filesystem but Formal will fetch the matching ids in memory and use them as input value.</p>"},{"location":"specifications/custom/","title":"Create first specification","text":"<p>Let's create a specification to target users by their name:</p> SearchByName.php<pre><code>use Innmind\\Specification\\{\n    Comparator\\Property,\n    Sign,\n};\n\nfinal class SearchByName\n{\n    public static function of(Name $name): Property\n    {\n        return Property::of(\n            'name', //(1)\n            Sign::equality,\n            $name, //(2)\n        );\n    }\n\n    public static function startingWith(Name $name): Property\n    {\n        return Property::of(\n            'name',\n            Sign::startsWith,\n            $name,\n        );\n    }\n}\n</code></pre> <ol> <li>This is the name of the property on the <code>User</code> class.</li> <li>The value type must be the same as the one declared on the Aggregate/Entity property.</li> </ol> <p>With this class you can create the rule:</p> <p>all users whose name is <code>alice</code> or <code>bob</code> or starts with a <code>j</code> except <code>john</code></p> <p>like this:</p> <pre><code>SearchByName::of(Name::of('alice'))\n    -&gt;or(SearchByName::of(Name::of('bob')))\n    -&gt;or(SearchByName::startsWith(Name::of('j')))\n    -&gt;and(\n        SearchByName::of('john')-&gt;not(),\n    );\n</code></pre>"},{"location":"specifications/custom/#targetting-entities","title":"Targetting entities","text":"<p>If you want to target users by city you'd have this specification:</p> SearchByCity.php<pre><code>use Innmind\\Specification\\{\n    Comparator\\Property,\n    Sign,\n};\n\nfinal class SearchByCity\n{\n    public static function of(string $city): Property\n    {\n        return Property::of('city', Sign::equality, $city);\n    }\n}\n</code></pre> <p>Depending of the kind of entity you'd use this like this:</p> Required EntityOptional EntityEntity colleciton <pre><code>use Formal\\ORM\\Specification\\Entity;\n\nEntity::of('address', SearchByCity::of('Paris'));\n</code></pre> <p><code>address</code> is the name of the property on <code>User</code></p> <pre><code>use Formal\\ORM\\Specification\\Just;\n\nJust::of('address', SearchByCity::of('Paris'));\n</code></pre> <p><code>address</code> is the name of the property on <code>User</code></p> <p>If the aggregate doesn't have an address specified then it won't be matched.</p> <p>If you only need to know if an entity exist you can use <code>Has</code>:</p> <pre><code>use Formal\\ORM\\Specification\\Has;\n\nHas::an('address');\n</code></pre> Warning <p>You MUST NOT negate a <code>Just</code> or a <code>Has</code> specification as it may not produce the results you'd expect. However you can negate the specification inside the <code>Just</code>.</p> <p>This is due to a behaviour inconsistency in Elasticsearch.</p> <pre><code>use Formal\\ORM\\Specification\\Child;\n\nChild::of('addresses', SearchByCity::of('Paris'));\n</code></pre> <p><code>addresses</code> is the name of the property on <code>User</code></p> <p>An aggregate will be matched as long as one address exist with this city.</p>"},{"location":"specifications/custom/#signin","title":"<code>Sign::in</code>","text":"<p>When using <code>Sign::in</code> the value of the specification must be either an <code>array</code>, a <code>Set</code> or a <code>Sequence</code> containing only values of the same type of the property. There MUST be at least one value.</p>"},{"location":"specifications/remove/","title":"Remove multiple aggregates","text":"<p>This is pretty straightforward:</p> <pre><code>$orm\n    -&gt;repository(User::class)\n    -&gt;remove(SearchByName::of(Name::of('alice')));\n</code></pre>"},{"location":"specifications/retrieve/","title":"Retrieve multiple aggregates","text":"<p>You can do so via the <code>matching</code> method on a repository:</p> <pre><code>$orm\n    -&gt;repository(User::class)\n    -&gt;matching(\n        SearchByName::of(Name::of('alice')),\n    )\n    -&gt;foreach(static fn(User $alice) =&gt; businessLogic($alice));\n</code></pre> Tip <p>The <code>foreach</code> method used here is a shortcut for <code>-&gt;sequence()-&gt;foreach()</code>. This means that you can have access to a <code>Sequence</code> by just calling <code>-&gt;sequence()</code> and use it like any other <code>Sequence</code>.</p>"},{"location":"use-cases/elasticsearch/","title":"Search an aggregate via Elasticsearch","text":"<p>If you have multiple aggregates (let's say <code>Product</code> and <code>Vendor</code>) that you want to query in a single specification, you'll need to create a third aggregate (ie <code>Search\\Product</code>) that will denormalize the data of both aggregates.</p> <p>These aggregates may look like this:</p> ProductVendorSearch product Product.php<pre><code>use Formal\\ORM\\Id;\n\nfinal readonly class Product\n{\n    /** @var Id&lt;self&gt; */\n    private Id $id;\n    private string $name;\n    /** @var Id&lt;Vendor&gt; */\n    private Id $vendor;\n\n    /**\n     * @param Id&lt;Vendor&gt; $vendor\n     */\n    public function __construct(string $name, Id $vendor)\n    {\n        $this-&gt;id = Id::new(self::class);\n        $this-&gt;name = $name;\n        $this-&gt;vendor = $vendor;\n    }\n\n    // Getters not displayed for conciseness\n}\n</code></pre> Vendor.php<pre><code>use Formal\\ORM\\Id;\n\nfinal readonly class Vendor\n{\n    /** @var Id&lt;self&gt; */\n    private Id $id;\n    private string $name;\n\n    public function __construct(string $name)\n    {\n        $this-&gt;id = Id::new(self::class);\n        $this-&gt;name = $name;\n    }\n\n    // Getters not displayed for conciseness\n}\n</code></pre> Search/Product.php<pre><code>namespace Search;\n\nuse Formal\\ORM\\Id;\n\nfinal readonly class Product\n{\n    /** @var Id&lt;self&gt; */\n    private Id $id;\n    /** @var Id&lt;\\Product&gt; */\n    private Id $productId;\n    private string $productName;\n    /** @var Id&lt;\\Vendor&gt; */\n    private Id $vendorId;\n    private string $vendorName;\n\n    public function __construct(\\Product $product, \\Vendor $vendor)\n    {\n        $this-&gt;id = Id::new(self::class);\n        $this-&gt;productId = $product-&gt;id();\n        $this-&gt;productName = $product-&gt;name();\n        $this-&gt;vendorId = $vendor-&gt;id();\n        $this-&gt;vendorName = $vendor-&gt;name();\n    }\n}\n</code></pre> <p>And to persist this new aggregate you would use 2 instances of the ORM like this:</p> <pre><code>use Formal\\ORM\\{\n    Manager,\n    Adapter\\Elasticsearch,\n};\nuse Innmind\\OperatingSystem\\Factory;\nuse Innmind\\Url\\Url;\nuse Innmind\\Immutable\\Either;\n\n$os = Factory::build();\n$sql = Manager::sql(\n    $os-&gt;remote()-&gt;sql(\n        Url::of('mysql://user:password@host:3306/database?charset=utf8mb4'),\n    ),\n);\n$elasticsearch = Manager::of(\n    Elasticsearch::of($os-&gt;remote()-&gt;http()),\n);\n\n$vendors = $sql-&gt;repository(Vendor::class);\n$searchableProducts = $sql\n    -&gt;repository(Product::class)\n    -&gt;all()\n    -&gt;flatMap(\n        static fn($product) =&gt; $vendors\n            -&gt;get($product-&gt;vendor())\n            -&gt;map(static fn($vendor) =&gt; new Search\\Product(\n                $product,\n                $vendor,\n            ))\n            -&gt;toSequence(), //(1)\n    );\n\n$repository = $elasticsearch-&gt;repository(Search\\Product::class);\n$elasticsearch-&gt;transactional(\n    static function() use ($repository, $searchableProducts) {\n        $_ = $searchableProducts-&gt;foreach($repository-&gt;put(...));\n\n        return Either::right(null);\n    },\n);\n</code></pre> <ol> <li>If the vendor doesn't exist the product is discarded.</li> </ol> <p>Then you can search these new aggregates as any other.</p>"},{"location":"use-cases/export/","title":"Export aggregates as a CSV","text":"<p>Since Formal sits on top of the Innmind ecosystem this pretty simple.</p> <pre><code>use Innmind\\OperatingSystem\\Factory;\nuse Innmind\\Filesystem\\{\n    File,\n    File\\Content\\Line,\n};\nuse Innmind\\Url\\Path;\nuse Innmind\\Immutable\\Str;\n\n$os = Factory::build();\n$lines = $orm\n    -&gt;repository(User::class)\n    -&gt;all()\n    -&gt;map(static fn(User $user): string =&gt; $user-&gt;name()-&gt;toString())\n    -&gt;map(Str::of(...))\n    -&gt;map(Line::of(...));\n$file = File::named(\n    'users.csv',\n    File\\Content::ofLines($lines),\n);\n$os\n    -&gt;filesystem()\n    -&gt;mount(Path::of('somewhere'))\n    -&gt;add($file);\n</code></pre> <p>This create a <code>users.csv</code> file where each line contains the name of a user.</p> <p>Since everything is lazy by default you can generate files of any size.</p> <p>You can learn more about handling files here.</p>"},{"location":"use-cases/import/","title":"Import aggregates from a CSV","text":""},{"location":"use-cases/import/#in-a-single-transaction","title":"In a single transaction","text":"<pre><code>use Innmind\\OperatingSystem\\Factory;\nuse Innmind\\Filesystem\\{\n    File,\n    Name as FileName,\n    File\\Content\\Line,\n};\nuse Innmind\\Url\\Path;\nuse Innmind\\Immutable\\{\n    Either,\n    Predicate\\Instance,\n};\n\n$os = Factory::of();\n$repository = $orm-&gt;repository(User::class);\n$orm-&gt;transactional(\n    static function() use ($os, $repository) {\n        $_ = $os\n            -&gt;filesystem()\n            -&gt;mount(Path::of('somewhere'))\n            -&gt;get(FileName::of('users.csv'))\n            -&gt;keep(Instance::of(File::class))\n            -&gt;toSequence()\n            -&gt;flatMap(static fn(File $users) =&gt; $users-&gt;content()-&gt;lines())\n            -&gt;map(static fn(Line $line) =&gt; User::new(Name::of(\n                $line-&gt;toString(), //(1)\n            )))\n            -&gt;foreach($repository-&gt;put(...));\n\n        return Either::right(null);\n    },\n);\n</code></pre> <ol> <li>Ths line never contains the <code>\\n</code> character, so you don't have to handle it yourself.</li> </ol>"},{"location":"use-cases/import/#commit-the-transaction-every-100-users","title":"Commit the transaction every 100 users","text":"<pre><code>use Innmind\\OperatingSystem\\Factory;\nuse Innmind\\Filesystem\\{\n    File,\n    Name as FileName,\n    File\\Content\\Line,\n};\nuse Innmind\\Url\\Path;\nuse Innmind\\Immutable\\{\n    Either,\n    Sequence,\n    Predicate\\Instance,\n};\n\n$os = Factory::of();\n$repository = $orm-&gt;repository(User::class);\n\n$_ = $os\n    -&gt;filesystem()\n    -&gt;mount(Path::of('somewhere'))\n    -&gt;get(FileName::of('users.csv'))\n    -&gt;keep(Instance::of(File::class))\n    -&gt;toSequence()\n    -&gt;flatMap(static fn(File $users) =&gt; $users-&gt;content()-&gt;lines())\n    -&gt;map(static fn(Line $line) =&gt; User::new(Name::of(\n        $line-&gt;toString(),\n    )))\n    -&gt;chunk(100)\n    -&gt;foreach(\n        static fn(Sequence $users) =&gt; $orm-&gt;transactional(\n            static function() use ($users, $repository) {\n                $users-&gt;foreach($repository-&gt;put(...));\n\n                return Either::right(null);\n            },\n        ),\n    );\n</code></pre>"},{"location":"blog/archive/2024/","title":"2024","text":""}]}